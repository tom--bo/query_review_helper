package main

import (
	"encoding/json"
	"flag"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"io"
	"os"
	"strings"
)

var (
	db *sqlx.DB
	host string
	port int
	user string
	password string
	database string
	socket string
)

func parseOptions() {
	flag.StringVar(&host, "h", "localhost", "mysql host")
	flag.IntVar(&port, "P", 3306, "mysql port")
	flag.StringVar(&user, "u", "root", "mysql user")
	flag.StringVar(&password, "p", "", "mysql password")
	flag.StringVar(&database, "d", "", "mysql database")
	flag.StringVar(&socket, "S", "", "mysql unix domain socket")

	flag.Parse()
}


func main() {
	parseOptions()
	f, err := os.Open("sample.json")
	if err != nil {
		fmt.Println("file open err")
		fmt.Println(err.Error())
		os.Exit(1)
	}
	defer f.Close()

	bytes, err := io.ReadAll(f)
	if err != nil {
		fmt.Println("file read err")
		fmt.Println(err.Error())
		os.Exit(1)
	}
	// jsonStr := string(bytes)
	// fmt.Println(jsonStr)

	tblJson := TblsFromOptimizer{}
	// tblJson := Autogenerated{}
	err = json.Unmarshal(bytes, &tblJson)
	if err != nil {
		fmt.Println("json unmarshal err")
		fmt.Println(err.Error())
		os.Exit(1)
	}
	connectMySQL()

	// Todo: step の1, 2番目に要素が来ないケースは一旦無視
	for _, tbl := range tblJson.Steps[1].JoinOptimization.Steps[2].TableDependencies {
		fmt.Println(tbl)
		tblName := strings.ReplaceAll(tbl.Table, "`", "")
		getKeys(database, tblName)
		fmt.Println("========")
	}

}


type TblsFromOptimizer struct {
	Steps []struct {
		JoinOptimization struct {
			Steps  []struct {
				TableDependencies []struct {
					Table            string        `json:"table"`
					RowMayBeNull     bool          `json:"row_may_be_null"`
					MapBit           int           `json:"map_bit"`
					DependsOnMapBits []interface{} `json:"depends_on_map_bits"`
				} `json:"table_dependencies,omitempty"`
			} `json:"steps"`
		} `json:"join_optimization,omitempty"`
	} `json:"steps"`
}


type Autogenerated struct {
	Steps []struct {
		JoinPreparation struct {
			Select int `json:"select#"`
			Steps  []struct {
				ExpandedQuery                string `json:"expanded_query,omitempty"`
				TransformationsToNestedJoins struct {
					Transformations []string `json:"transformations"`
					ExpandedQuery   string   `json:"expanded_query"`
				} `json:"transformations_to_nested_joins,omitempty"`
			} `json:"steps"`
		} `json:"join_preparation,omitempty"`
		JoinOptimization struct {
			Select int `json:"select#"`
			Steps  []struct {
				ConditionProcessing struct {
					Condition         string `json:"condition"`
					OriginalCondition string `json:"original_condition"`
					Steps             []struct {
						Transformation     string `json:"transformation"`
						ResultingCondition string `json:"resulting_condition"`
					} `json:"steps"`
				} `json:"condition_processing,omitempty"`
				SubstituteGeneratedColumns struct {
				} `json:"substitute_generated_columns,omitempty"`
				TableDependencies []struct {
					Table            string        `json:"table"`
					RowMayBeNull     bool          `json:"row_may_be_null"`
					MapBit           int           `json:"map_bit"`
					DependsOnMapBits []interface{} `json:"depends_on_map_bits"`
				} `json:"table_dependencies,omitempty"`
				RefOptimizerKeyUses []struct {
					Table         string `json:"table"`
					Field         string `json:"field"`
					Equals        string `json:"equals"`
					NullRejecting bool   `json:"null_rejecting"`
				} `json:"ref_optimizer_key_uses,omitempty"`
				RowsEstimation []struct {
					Table     string `json:"table"`
					TableScan struct {
						Rows int     `json:"rows"`
						Cost float64 `json:"cost"`
					} `json:"table_scan"`
				} `json:"rows_estimation,omitempty"`
				ConsideredExecutionPlans []struct {
					PlanPrefix     []interface{} `json:"plan_prefix"`
					Table          string        `json:"table"`
					BestAccessPath struct {
						ConsideredAccessPaths []struct {
							AccessType           string        `json:"access_type"`
							Index                string        `json:"index,omitempty"`
							Usable               bool          `json:"usable,omitempty"`
							Chosen               bool          `json:"chosen"`
							RowsToScan           int           `json:"rows_to_scan,omitempty"`
							FilteringEffect      []interface{} `json:"filtering_effect,omitempty"`
							FinalFilteringEffect int           `json:"final_filtering_effect,omitempty"`
							ResultingRows        int           `json:"resulting_rows,omitempty"`
							Cost                 float64       `json:"cost,omitempty"`
						} `json:"considered_access_paths"`
					} `json:"best_access_path"`
					ConditionFilteringPct int     `json:"condition_filtering_pct"`
					RowsForPlan           int     `json:"rows_for_plan"`
					CostForPlan           float64 `json:"cost_for_plan"`
					RestOfPlan            []struct {
						PlanPrefix     []string `json:"plan_prefix"`
						Table          string   `json:"table"`
						BestAccessPath struct {
							ConsideredAccessPaths []struct {
								AccessType           string        `json:"access_type"`
								Index                string        `json:"index,omitempty"`
								Rows                 int           `json:"rows,omitempty"`
								Cost                 float64       `json:"cost"`
								Chosen               bool          `json:"chosen"`
								Cause                string        `json:"cause,omitempty"`
								RowsToScan           int           `json:"rows_to_scan,omitempty"`
								FilteringEffect      []interface{} `json:"filtering_effect,omitempty"`
								FinalFilteringEffect int           `json:"final_filtering_effect,omitempty"`
								UsingJoinCache       bool          `json:"using_join_cache,omitempty"`
								BuffersNeeded        int           `json:"buffers_needed,omitempty"`
								ResultingRows        int           `json:"resulting_rows,omitempty"`
							} `json:"considered_access_paths"`
						} `json:"best_access_path"`
						ConditionFilteringPct int     `json:"condition_filtering_pct"`
						RowsForPlan           int     `json:"rows_for_plan"`
						CostForPlan           float64 `json:"cost_for_plan"`
						Chosen                bool    `json:"chosen"`
					} `json:"rest_of_plan"`
				} `json:"considered_execution_plans,omitempty"`
				AttachingConditionsToTables struct {
					OriginalCondition             string        `json:"original_condition"`
					AttachedConditionsComputation []interface{} `json:"attached_conditions_computation"`
					AttachedConditionsSummary     []struct {
						Table    string      `json:"table"`
						Attached interface{} `json:"attached"`
					} `json:"attached_conditions_summary"`
				} `json:"attaching_conditions_to_tables,omitempty"`
				FinalizingTableConditions []struct {
					Table                  string      `json:"table"`
					OriginalTableCondition string      `json:"original_table_condition"`
					FinalTableCondition    interface{} `json:"final_table_condition   "`
				} `json:"finalizing_table_conditions,omitempty"`
				RefinePlan []struct {
					Table string `json:"table"`
				} `json:"refine_plan,omitempty"`
			} `json:"steps"`
		} `json:"join_optimization,omitempty"`
		JoinExecution struct {
			Select int           `json:"select#"`
			Steps  []interface{} `json:"steps"`
		} `json:"join_execution,omitempty"`
	} `json:"steps"`
}
