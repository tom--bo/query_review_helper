package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"github.com/jmoiron/sqlx"
	"io"
	"os"
	"strings"
)

var (
	db *sqlx.DB
	rdr = bufio.NewReaderSize(os.Stdin, 1000000)
	host string
	port int
	user string
	password string
	database string
	socket string
)

func parseOptions() {
	flag.StringVar(&host, "h", "localhost", "mysql host")
	flag.IntVar(&port, "P", 3306, "mysql port")
	flag.StringVar(&user, "u", "root", "mysql user")
	flag.StringVar(&password, "p", "", "mysql password")
	flag.StringVar(&database, "d", "", "mysql database")
	flag.StringVar(&socket, "S", "", "mysql unix domain socket")

	flag.Parse()
}


func main() {
	fmt.Println("(Input query and ^D at the last line)")
	parseOptions()

	// read from file
	/*
	f, err := os.Open("sample.json")
	if err != nil {
		fmt.Println("file open err")
		fmt.Println(err.Error())
		os.Exit(1)
	}
	defer f.Close()

	bytes, err := io.ReadAll(f)
	if err != nil {
		fmt.Println("file read err")
		fmt.Println(err.Error())
		os.Exit(1)
	}
	*/

	q := readLine()

	err := connectMySQL()
	if err != nil {
		fmt.Println("Connect MySQL err", err.Error())
		os.Exit(1)
	}

	trace, err := getOptimizerTrace(q)
	if err != nil {
		fmt.Println("get trace err", err.Error())
		os.Exit(1)
	}

	// fmt.Println(trace)
	bytes := []byte(trace)

	tblJson := TblsFromOptimizer{}
	// tblJson := Autogenerated{}
	err = json.Unmarshal(bytes, &tblJson)
	if err != nil {
		fmt.Println("json unmarshal err")
		fmt.Println(err.Error())
		os.Exit(1)
	}


	// Todo: step の1, 2番目に要素が来ないケースは一旦無視
	fmt.Println("\n==== Tables ====")
	for _, tbl := range tblJson.Steps[1].JoinOptimization.Steps[2].TableDependencies {
		tblName := strings.ReplaceAll(tbl.Table, "`", "")
		fmt.Println("- " + tblName)
	}
	fmt.Println("\n==== Indexes ====")
	for _, tbl := range tblJson.Steps[1].JoinOptimization.Steps[2].TableDependencies {
		tblName := strings.ReplaceAll(tbl.Table, "`", "")
		fmt.Println("== " + tblName + " ==")
		info, err := getKeys(database, tblName)
		if err != nil {
			fmt.Println("Get keys err", err.Error())
			os.Exit(1)
		}
		fmt.Printf("%-10s: %s\n", "PRIMARY", info.pkColumns)
		for k, v := range info.indexes {
			fmt.Printf("%-10s: %s\n", v, k)
		}

		// cardinality取得のサンプル
		// cardinality, err := samplingColumnCardinality(tblName, info.pkColumns, "c1", 100)
		// if err != nil {
		// 	fmt.Println(err.Error())
		// 	os.Exit(1)
		// }
		// fmt.Printf("Cardinality %s.c1 is %d\n", tblName, cardinality)
	}

}

func readLine() string {
	buf := make([]byte, 0, 1000000)
	for {
		l, err := rdr.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
		buf = append(buf, l...)
	}
	return string(buf)
}

type TblsFromOptimizer struct {
	Steps []struct {
		JoinOptimization struct {
			Steps  []struct {
				TableDependencies []struct {
					Table            string        `json:"table"`
					RowMayBeNull     bool          `json:"row_may_be_null"`
					MapBit           int           `json:"map_bit"`
					DependsOnMapBits []interface{} `json:"depends_on_map_bits"`
				} `json:"table_dependencies,omitempty"`
			} `json:"steps"`
		} `json:"join_optimization,omitempty"`
	} `json:"steps"`
}
